// Generated by CoffeeScript 1.3.1
(function() {

  module.exports = function(config) {
    var async, defaultConfig, monitor, _;
    _ = require('underscore');
    async = require('async');
    monitor = {};
    defaultConfig = {
      enabled: true,
      project: 'My project',
      defaultType: 'error',
      logger: {
        file: __dirname + '/logs/error.log',
        handler: process.env.NODE_ENV !== 'test' ? require(__dirname + '/logger/file') : void 0
      },
      monitorTypes: {
        production: ['critical'],
        stage: ['critical', 'error', 'event'],
        test: ['critical', 'error', 'event', 'debug'],
        development: ['critical', 'error', 'event', 'debug']
      }
    };
    _.extend(monitor.config = {}, defaultConfig, config);
    monitor.trackUsageCycles = 0;
    monitor.trackUsage = function(callback) {
      var check;
      if (!monitor.config.enabled) {
        callback();
        return;
      }
      check = function(error) {
        var recursiveFn;
        if (monitor.config.usage.cycle === false) {
          return;
        }
        if (error) {
          callback(error);
        }
        monitor.trackUsageCycles++;
        recursiveFn = async.apply(monitor.checkUsage, check);
        switch (monitor.config.usage.cycle) {
          case false:
            return;
          case -1:
            1;

            break;
          case 0:
            async.nextTick(recursiveFn);
            break;
          default:
            setTimeout(recursiveFn, monitor.config.usage.cycle);
        }
        return callback();
      };
      return monitor.checkUsage(check);
    };
    monitor.checkUsage = function(callback) {
      var checkResource, config, resource, resources, _ref;
      if (callback == null) {
        callback = function() {};
      }
      if (!monitor.config.enabled) {
        callback();
        return;
      }
      checkResource = function(config, eventsCallback) {
        var events, value;
        if (eventsCallback == null) {
          eventsCallback = function() {};
        }
        if (!((_.isUndefined(config.enabled)) || config.enabled === true)) {
          eventsCallback();
          return;
        }
        if (!_.isFunction(config.handler)) {
          eventsCallback('Unknown usage handler');
          return;
        }
        events = [];
        value = config.handler(function(error, value) {
          var buffer, condition, event, _ref, _results;
          _ref = config.listeners;
          _results = [];
          for (event in _ref) {
            condition = _ref[event];
            if (typeof condition === 'integer') {
              if (value >= condition) {
                if (_.isFunction(config.events[event])) {
                  events.push(async.apply(config.events[event], value));
                }
              }
              continue;
            } else if (typeof condition !== 'string') {
              continue;
            }
            buffer = condition.match(/([<>=]+)(\d+)/);
            if (!buffer) {
              continue;
            }
            buffer[2] = parseInt(buffer[2]);
            switch (buffer[1]) {
              case '>':
                if (value > buffer[2]) {
                  if (_.isFunction(config.events[event])) {
                    _results.push(events.push(async.apply(config.events[event], value)));
                  } else {
                    _results.push(void 0);
                  }
                } else {
                  _results.push(void 0);
                }
                break;
              case '>=':
                if (value >= buffer[2]) {
                  if (_.isFunction(config.events[event])) {
                    _results.push(events.push(async.apply(config.events[event], value)));
                  } else {
                    _results.push(void 0);
                  }
                } else {
                  _results.push(void 0);
                }
                break;
              case '<':
                if (value < buffer[2]) {
                  if (_.isFunction(config.events[event])) {
                    _results.push(events.push(async.apply(config.events[event], value)));
                  } else {
                    _results.push(void 0);
                  }
                } else {
                  _results.push(void 0);
                }
                break;
              case '<=':
                if (value <= buffer[2]) {
                  if (_.isFunction(config.events[event])) {
                    _results.push(events.push(async.apply(config.events[event], value)));
                  } else {
                    _results.push(void 0);
                  }
                } else {
                  _results.push(void 0);
                }
                break;
              case '=':
                if (value === buffer[2]) {
                  if (_.isFunction(config.events[event])) {
                    _results.push(events.push(async.apply(config.events[event], value)));
                  } else {
                    _results.push(void 0);
                  }
                } else {
                  _results.push(void 0);
                }
                break;
              default:
                _results.push(void 0);
            }
          }
          return _results;
        });
        return async.parallel(events, eventsCallback);
      };
      resources = [];
      _ref = monitor.config.usage.resources;
      for (resource in _ref) {
        config = _ref[resource];
        resources.push(async.apply(checkResource, config));
      }
      return async.parallel(resources, callback);
    };
    monitor.log = function(message, object, type, callback) {
      var logger, validTypes;
      if (object == null) {
        object = null;
      }
      if (type == null) {
        type = monitor.defaultType;
      }
      if (callback == null) {
        callback = function() {};
      }
      if (!monitor.config.enabled) {
        callback();
        return;
      }
      validTypes = _.isArray(monitor.config.monitorTypes) ? monitor.config.monitorTypes : monitor.config.monitorTypes[process.env.NODE_ENV];
      if (_.indexOf(validTypes, type) === -1) {
        callback();
        return;
      }
      if (!_.isFunction(monitor.config.logger.handler)) {
        if (!_.isUndefined(monitor.config.logger[process.env.NODE_ENV])) {
          if (!_.isFunction(monitor.config.logger[process.env.NODE_ENV].handler)) {
            if (!_.isUndefined(monitor.config.logger[process.env.NODE_ENV][type])) {
              if (_.isFunction(monitor.config.logger[process.env.NODE_ENV][type].handler)) {
                logger = monitor.config.logger[process.env.NODE_ENV][type];
              }
            } else if (!_.isUndefined(monitor.config.logger[process.env.NODE_ENV]['default'])) {
              if (_.isFunction(monitor.config.logger[process.env.NODE_ENV]['default'].handler)) {
                logger = monitor.config.logger[process.env.NODE_ENV]['default'];
              }
            }
          } else {
            logger = monitor.config.logger[process.env.NODE_ENV];
          }
        } else if (!logger) {
          if (!_.isUndefined(monitor.config.logger[type])) {
            if (_.isFunction(monitor.config.logger[type].handler)) {
              logger = monitor.config.logger[type];
            }
          } else if (!_.isUndefined(monitor.config.logger['default'])) {
            if (_.isFunction(monitor.config.logger['default'].handler)) {
              logger = monitor.config.logger['default'];
            }
          }
        }
      } else {
        logger = monitor.config.logger;
      }
      if (!logger) {
        callback('Unknown logging function');
        return;
      }
      if (!((_.isUndefined(logger.enabled)) || logger.enabled === true)) {
        callback();
        return;
      }
      return logger.handler(monitor.config, logger, message, object, type, callback);
    };
    monitor.critical = function(message, object, callback) {
      if (object == null) {
        object = null;
      }
      if (callback == null) {
        callback = function() {};
      }
      return monitor.log(message, object, 'critical', callback);
    };
    monitor.error = function(message, object, callback) {
      if (object == null) {
        object = null;
      }
      if (callback == null) {
        callback = function() {};
      }
      return monitor.log(message, object, 'error', callback);
    };
    monitor.event = function(message, object, callback) {
      if (object == null) {
        object = null;
      }
      if (callback == null) {
        callback = function() {};
      }
      return monitor.log(message, object, 'event', callback);
    };
    monitor.debug = function(message, object, callback) {
      if (object == null) {
        object = null;
      }
      if (callback == null) {
        callback = function() {};
      }
      return monitor.log(message, object, 'debug', callback);
    };
    return monitor;
  };

}).call(this);
